// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2014.4
// Copyright (C) 2014 Xilinx Inc. All rights reserved.
// 
// ==============================================================


`timescale 1 ns / 1 ps

module AESL_axi_s_INPUT_STREAM (
    clk,
    reset,
    TRAN_INPUT_STREAM_TDATA,
    TRAN_INPUT_STREAM_TKEEP,
    TRAN_INPUT_STREAM_TSTRB,
    TRAN_INPUT_STREAM_TUSER,
    TRAN_INPUT_STREAM_TLAST,
    TRAN_INPUT_STREAM_TID,
    TRAN_INPUT_STREAM_TDEST,
    TRAN_INPUT_STREAM_TVALID,
    TRAN_INPUT_STREAM_TREADY,
    ready,
    done
    );

//------------------------Parameter----------------------
`define TV_IN_INPUT_STREAM_TDATA "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_data_V.dat"
`define TV_IN_INPUT_STREAM_TKEEP "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_keep_V.dat"
`define TV_IN_INPUT_STREAM_TSTRB "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_strb_V.dat"
`define TV_IN_INPUT_STREAM_TUSER "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_user_V.dat"
`define TV_IN_INPUT_STREAM_TLAST "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_last_V.dat"
`define TV_IN_INPUT_STREAM_TID "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_id_V.dat"
`define TV_IN_INPUT_STREAM_TDEST "../tv/cdatafile/c.image_filter.autotvin_INPUT_STREAM_V_dest_V.dat"
// Input and Output
input clk;
input reset;
output [31 : 0] TRAN_INPUT_STREAM_TDATA;
output [3 : 0] TRAN_INPUT_STREAM_TKEEP;
output [3 : 0] TRAN_INPUT_STREAM_TSTRB;
output  TRAN_INPUT_STREAM_TUSER;
output  TRAN_INPUT_STREAM_TLAST;
output  TRAN_INPUT_STREAM_TID;
output  TRAN_INPUT_STREAM_TDEST;
output  TRAN_INPUT_STREAM_TVALID;
input  TRAN_INPUT_STREAM_TREADY;
input ready;
input done;

//------------------------Local signal-------------------
reg [31 : 0] mem_INPUT_STREAM_TDATA [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TDATA
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TDATA[i] = 0;
  end
end
wire INPUT_STREAM_TDATA_empty_n;
wire INPUT_STREAM_TDATA_full_n;
reg [22 : 0]  INPUT_STREAM_TDATA_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TDATA_mOutPtr =   0;
reg  INPUT_STREAM_TDATA_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

reg [3 : 0] mem_INPUT_STREAM_TKEEP [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TKEEP
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TKEEP[i] = 0;
  end
end
wire INPUT_STREAM_TKEEP_empty_n;
wire INPUT_STREAM_TKEEP_full_n;
reg [22 : 0]  INPUT_STREAM_TKEEP_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TKEEP_mOutPtr =   0;
reg  INPUT_STREAM_TKEEP_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

reg [3 : 0] mem_INPUT_STREAM_TSTRB [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TSTRB
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TSTRB[i] = 0;
  end
end
wire INPUT_STREAM_TSTRB_empty_n;
wire INPUT_STREAM_TSTRB_full_n;
reg [22 : 0]  INPUT_STREAM_TSTRB_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TSTRB_mOutPtr =   0;
reg  INPUT_STREAM_TSTRB_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

reg [0 : 0] mem_INPUT_STREAM_TUSER [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TUSER
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TUSER[i] = 0;
  end
end
wire INPUT_STREAM_TUSER_empty_n;
wire INPUT_STREAM_TUSER_full_n;
reg [22 : 0]  INPUT_STREAM_TUSER_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TUSER_mOutPtr =   0;
reg  INPUT_STREAM_TUSER_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

reg [0 : 0] mem_INPUT_STREAM_TLAST [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TLAST
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TLAST[i] = 0;
  end
end
wire INPUT_STREAM_TLAST_empty_n;
wire INPUT_STREAM_TLAST_full_n;
reg [22 : 0]  INPUT_STREAM_TLAST_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TLAST_mOutPtr =   0;
reg  INPUT_STREAM_TLAST_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

reg [0 : 0] mem_INPUT_STREAM_TID [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TID
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TID[i] = 0;
  end
end
wire INPUT_STREAM_TID_empty_n;
wire INPUT_STREAM_TID_full_n;
reg [22 : 0]  INPUT_STREAM_TID_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TID_mOutPtr =   0;
reg  INPUT_STREAM_TID_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

reg [0 : 0] mem_INPUT_STREAM_TDEST [2073600 : 0];
initial begin : initialize_mem_INPUT_STREAM_TDEST
  integer i;
  for (i = 0; i < 2073600; i = i + 1) begin
      mem_INPUT_STREAM_TDEST[i] = 0;
  end
end
wire INPUT_STREAM_TDEST_empty_n;
wire INPUT_STREAM_TDEST_full_n;
reg [22 : 0]  INPUT_STREAM_TDEST_mInPtr  =   0;
reg [22 : 0]  INPUT_STREAM_TDEST_mOutPtr =   0;
reg  INPUT_STREAM_TDEST_mFlag_nEF_hint;  // 0: empty hint, 1: full hint

assign TRAN_INPUT_STREAM_TDATA = mem_INPUT_STREAM_TDATA[INPUT_STREAM_TDATA_mOutPtr];
assign INPUT_STREAM_TDATA_empty_n	=	((INPUT_STREAM_TDATA_mInPtr == INPUT_STREAM_TDATA_mOutPtr) && INPUT_STREAM_TDATA_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TDATA_full_n	=	((INPUT_STREAM_TDATA_mInPtr == INPUT_STREAM_TDATA_mOutPtr) && INPUT_STREAM_TDATA_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
assign TRAN_INPUT_STREAM_TKEEP = mem_INPUT_STREAM_TKEEP[INPUT_STREAM_TKEEP_mOutPtr];
assign INPUT_STREAM_TKEEP_empty_n	=	((INPUT_STREAM_TKEEP_mInPtr == INPUT_STREAM_TKEEP_mOutPtr) && INPUT_STREAM_TKEEP_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TKEEP_full_n	=	((INPUT_STREAM_TKEEP_mInPtr == INPUT_STREAM_TKEEP_mOutPtr) && INPUT_STREAM_TKEEP_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
assign TRAN_INPUT_STREAM_TSTRB = mem_INPUT_STREAM_TSTRB[INPUT_STREAM_TSTRB_mOutPtr];
assign INPUT_STREAM_TSTRB_empty_n	=	((INPUT_STREAM_TSTRB_mInPtr == INPUT_STREAM_TSTRB_mOutPtr) && INPUT_STREAM_TSTRB_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TSTRB_full_n	=	((INPUT_STREAM_TSTRB_mInPtr == INPUT_STREAM_TSTRB_mOutPtr) && INPUT_STREAM_TSTRB_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
assign TRAN_INPUT_STREAM_TUSER = mem_INPUT_STREAM_TUSER[INPUT_STREAM_TUSER_mOutPtr];
assign INPUT_STREAM_TUSER_empty_n	=	((INPUT_STREAM_TUSER_mInPtr == INPUT_STREAM_TUSER_mOutPtr) && INPUT_STREAM_TUSER_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TUSER_full_n	=	((INPUT_STREAM_TUSER_mInPtr == INPUT_STREAM_TUSER_mOutPtr) && INPUT_STREAM_TUSER_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
assign TRAN_INPUT_STREAM_TLAST = mem_INPUT_STREAM_TLAST[INPUT_STREAM_TLAST_mOutPtr];
assign INPUT_STREAM_TLAST_empty_n	=	((INPUT_STREAM_TLAST_mInPtr == INPUT_STREAM_TLAST_mOutPtr) && INPUT_STREAM_TLAST_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TLAST_full_n	=	((INPUT_STREAM_TLAST_mInPtr == INPUT_STREAM_TLAST_mOutPtr) && INPUT_STREAM_TLAST_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
assign TRAN_INPUT_STREAM_TID = mem_INPUT_STREAM_TID[INPUT_STREAM_TID_mOutPtr];
assign INPUT_STREAM_TID_empty_n	=	((INPUT_STREAM_TID_mInPtr == INPUT_STREAM_TID_mOutPtr) && INPUT_STREAM_TID_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TID_full_n	=	((INPUT_STREAM_TID_mInPtr == INPUT_STREAM_TID_mOutPtr) && INPUT_STREAM_TID_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
assign TRAN_INPUT_STREAM_TDEST = mem_INPUT_STREAM_TDEST[INPUT_STREAM_TDEST_mOutPtr];
assign INPUT_STREAM_TDEST_empty_n	=	((INPUT_STREAM_TDEST_mInPtr == INPUT_STREAM_TDEST_mOutPtr) && INPUT_STREAM_TDEST_mFlag_nEF_hint == 1'b0)? 1'b 0: 1'b 1;
assign INPUT_STREAM_TDEST_full_n	=	((INPUT_STREAM_TDEST_mInPtr == INPUT_STREAM_TDEST_mOutPtr) && INPUT_STREAM_TDEST_mFlag_nEF_hint == 1'b1)? 1'b 0: 1'b 1;
// Inner signals
assign TRAN_INPUT_STREAM_TVALID = 1 & 
    INPUT_STREAM_TDATA_empty_n &
    INPUT_STREAM_TKEEP_empty_n &
    INPUT_STREAM_TSTRB_empty_n &
    INPUT_STREAM_TUSER_empty_n &
    INPUT_STREAM_TLAST_empty_n &
    INPUT_STREAM_TID_empty_n &
    INPUT_STREAM_TDEST_empty_n &
      1;
//------------------------Task and function--------------
task read_token;
	input integer fp;
  output reg [183 : 0] token;
	reg [7:0] c;
	reg intoken;
	reg done;
	begin
	    token = "";
	    intoken = 0;
	    done = 0;
	    while (!done) begin
		c = $fgetc(fp);
		if (c == 8'hff) begin	// EOF
		    done = 1;
		end
		else if (c == " " || c == "\011" || c == "\012" || c == "\015") begin   // blank
		    if (intoken) begin
			done = 1;
		    end
		end
		else begin			// valid character
		    intoken = 1;
		    token = (token << 8) | c;
		end
	    end
	end
endtask

//------------------------Read-only axi_s-------------------

// Write operation for read_only axi_s port
initial begin : INPUT_STREAM_TDATA_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [32 : 0] mem_INPUT_STREAM_TDATA_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TDATA_mInPtr = 0;
  INPUT_STREAM_TDATA_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TDATA,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TDATA);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TDATA_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TDATA_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TDATA_tmp);
          mem_INPUT_STREAM_TDATA[INPUT_STREAM_TDATA_mInPtr] = mem_INPUT_STREAM_TDATA_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TDATA_mInPtr = INPUT_STREAM_TDATA_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TDATA_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TDATA_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TDATA
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TDATA_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TDATA_mOutPtr < INPUT_STREAM_TDATA_mInPtr)
	        INPUT_STREAM_TDATA_mOutPtr <= INPUT_STREAM_TDATA_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TDATA_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TDATA_mOutPtr = 0;
  end
end

initial begin : INPUT_STREAM_TKEEP_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [4 : 0] mem_INPUT_STREAM_TKEEP_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TKEEP_mInPtr = 0;
  INPUT_STREAM_TKEEP_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TKEEP,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TKEEP);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TKEEP_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TKEEP_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TKEEP_tmp);
          mem_INPUT_STREAM_TKEEP[INPUT_STREAM_TKEEP_mInPtr] = mem_INPUT_STREAM_TKEEP_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TKEEP_mInPtr = INPUT_STREAM_TKEEP_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TKEEP_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TKEEP_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TKEEP
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TKEEP_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TKEEP_mOutPtr < INPUT_STREAM_TKEEP_mInPtr)
	        INPUT_STREAM_TKEEP_mOutPtr <= INPUT_STREAM_TKEEP_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TKEEP_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TKEEP_mOutPtr = 0;
  end
end

initial begin : INPUT_STREAM_TSTRB_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [4 : 0] mem_INPUT_STREAM_TSTRB_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TSTRB_mInPtr = 0;
  INPUT_STREAM_TSTRB_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TSTRB,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TSTRB);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TSTRB_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TSTRB_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TSTRB_tmp);
          mem_INPUT_STREAM_TSTRB[INPUT_STREAM_TSTRB_mInPtr] = mem_INPUT_STREAM_TSTRB_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TSTRB_mInPtr = INPUT_STREAM_TSTRB_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TSTRB_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TSTRB_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TSTRB
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TSTRB_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TSTRB_mOutPtr < INPUT_STREAM_TSTRB_mInPtr)
	        INPUT_STREAM_TSTRB_mOutPtr <= INPUT_STREAM_TSTRB_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TSTRB_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TSTRB_mOutPtr = 0;
  end
end

initial begin : INPUT_STREAM_TUSER_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [1 : 0] mem_INPUT_STREAM_TUSER_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TUSER_mInPtr = 0;
  INPUT_STREAM_TUSER_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TUSER,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TUSER);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TUSER_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TUSER_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TUSER_tmp);
          mem_INPUT_STREAM_TUSER[INPUT_STREAM_TUSER_mInPtr] = mem_INPUT_STREAM_TUSER_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TUSER_mInPtr = INPUT_STREAM_TUSER_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TUSER_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TUSER_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TUSER
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TUSER_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TUSER_mOutPtr < INPUT_STREAM_TUSER_mInPtr)
	        INPUT_STREAM_TUSER_mOutPtr <= INPUT_STREAM_TUSER_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TUSER_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TUSER_mOutPtr = 0;
  end
end

initial begin : INPUT_STREAM_TLAST_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [1 : 0] mem_INPUT_STREAM_TLAST_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TLAST_mInPtr = 0;
  INPUT_STREAM_TLAST_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TLAST,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TLAST);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TLAST_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TLAST_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TLAST_tmp);
          mem_INPUT_STREAM_TLAST[INPUT_STREAM_TLAST_mInPtr] = mem_INPUT_STREAM_TLAST_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TLAST_mInPtr = INPUT_STREAM_TLAST_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TLAST_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TLAST_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TLAST
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TLAST_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TLAST_mOutPtr < INPUT_STREAM_TLAST_mInPtr)
	        INPUT_STREAM_TLAST_mOutPtr <= INPUT_STREAM_TLAST_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TLAST_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TLAST_mOutPtr = 0;
  end
end

initial begin : INPUT_STREAM_TID_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [1 : 0] mem_INPUT_STREAM_TID_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TID_mInPtr = 0;
  INPUT_STREAM_TID_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TID,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TID);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TID_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TID_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TID_tmp);
          mem_INPUT_STREAM_TID[INPUT_STREAM_TID_mInPtr] = mem_INPUT_STREAM_TID_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TID_mInPtr = INPUT_STREAM_TID_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TID_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TID_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TID
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TID_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TID_mOutPtr < INPUT_STREAM_TID_mInPtr)
	        INPUT_STREAM_TID_mOutPtr <= INPUT_STREAM_TID_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TID_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TID_mOutPtr = 0;
  end
end

initial begin : INPUT_STREAM_TDEST_read_file_process
  integer fp;
  integer err;
  integer ret;
  integer transaction_idx;
  reg [183 : 0] token;
  reg [1 : 0] mem_INPUT_STREAM_TDEST_tmp ;
  reg [ 8*5 : 1] str;
  INPUT_STREAM_TDEST_mInPtr = 0;
  INPUT_STREAM_TDEST_mFlag_nEF_hint = 0;
  transaction_idx = 0;
  fp = $fopen(`TV_IN_INPUT_STREAM_TDEST,"r");
  if(fp == 0) begin       // Failed to open file
	    $display("Failed to open file \"%s\"!", `TV_IN_INPUT_STREAM_TDEST);
	    $finish;
  end
  read_token(fp, token);
  if (token != "[[[runtime]]]") begin             // Illegal format
      $display("ERROR: Simulation using HLS TB failed.");
	    $finish;
  end
  read_token(fp, token);
  while (token != "[[[/runtime]]]") begin
      if (token != "[[transaction]]") begin
          $display("ERROR: Simulation using HLS TB failed.");
          $finish;
      end
      read_token(fp, token);              // skip transaction number

      @(posedge clk);
      # 0.2;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.2;
      end
      read_token(fp,token);
      INPUT_STREAM_TDEST_mInPtr = 0;
      while(token != "[[/transaction]]") begin
          if (INPUT_STREAM_TDEST_mInPtr >= 2073600 ) begin
              $display("Fifo overflow!");
  	        $finish;
          end
          ret = $sscanf(token, "0x%x", mem_INPUT_STREAM_TDEST_tmp);
          mem_INPUT_STREAM_TDEST[INPUT_STREAM_TDEST_mInPtr] = mem_INPUT_STREAM_TDEST_tmp;
          if (ret != 1) begin
              $display("Failed to parse token!");
              $finish;
          end
          INPUT_STREAM_TDEST_mInPtr = INPUT_STREAM_TDEST_mInPtr + 1;
          read_token(fp, token);
      end
      INPUT_STREAM_TDEST_mFlag_nEF_hint = 0;
      read_token(fp, token);
      transaction_idx = transaction_idx + 1;
  end
  $fclose(fp);
  @(posedge clk);
  # 0.2;
  while(ready !== 1) begin
  # 0.2;
      @(posedge clk);
  end
  INPUT_STREAM_TDEST_mFlag_nEF_hint = 1;
end

// Read operation for read_only axi_s signal INPUT_STREAM_TDEST
always @ (posedge clk) begin
    if (reset === 0) begin
      INPUT_STREAM_TDEST_mOutPtr = 0;
  end
  else if(TRAN_INPUT_STREAM_TVALID && TRAN_INPUT_STREAM_TREADY) begin
	    if(INPUT_STREAM_TDEST_mOutPtr < INPUT_STREAM_TDEST_mInPtr)
	        INPUT_STREAM_TDEST_mOutPtr <= INPUT_STREAM_TDEST_mOutPtr + 1;
  end
end

// Reset mOutPtr when done is pulled up
initial begin : done_reset_INPUT_STREAM_TDEST_mOutPtr_process
  while(1) begin
      @(posedge clk);
      # 0.1;
      while(ready !== 1) begin
          @(posedge clk);
          # 0.1;
      end
      INPUT_STREAM_TDEST_mOutPtr = 0;
  end
end

endmodule
